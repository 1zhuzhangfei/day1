<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>异步与事件循环</title>
</head>

<body>

</body>

<script>

    //工厂（程序） 车间（进程） 工人（线程） 能源（CPU）
    //进程是程序运行的实例，也是系统分配资源的最小单位
    //一个进程可以包含多个线程，线程是CPU调度的最小单位
    //chrome浏览器是一个多进程多线程的模型
    //浏览器进程，GPU进程，渲染进程，插件进程（进程之间是相互独立不影响）
    //渲染进程中包含多个线程（JavaScript主线程，定时器线程，网络线程，GUI线程，事件线程----线程共享进程的资源）

    var a = 1;
    var b = 2;
    setTimeout(function () {
        console.log(6);
    }, 2000);
    console.log(a + b);
    var div = document.querySelector('div');
    div.addEventListener('click', function () {
        console.log(4);
    })
    console.log(5);

</script>

<!-- 
任务队列： [] 
主线程： <script>
IO线程： 
定时器线程：2s后将任务2推入任务队列
渲染任务：
-->



<!-- 
任务循环：主线程一直在循环的执行队列中的任务，请求动画帧回调，渲染
JS主线程初始化完成后就会一直循环
script标签里面的所有代码会包装成一个任务 推入任务队列 这是所有任务的起点
按部就班的一步一步执行同步代码，如果遇到可以创建task（任务）的API（定时器，事件）那么就交给对应的线程去管理 在恰当事件/满足触发条件
当一个任务完成的时候 需要判断当前界面是否需要更新（界面上元素的几何，外观信息）且有没有到更新的时间（1000/显示器刷新率）
如果需要更新 就先执行请求动画帧的回调函数然后渲染页面（style Layout Paint）
如果不需要更新 则继续取任务队列头部的第一个任务以此循环
-->

</html>